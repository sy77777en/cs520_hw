"""
FIND_PRODUCT - Generated Specifications (Before Correction)
Generated by LLM from natural language description
"""

# These assertions are BEFORE manual correction
# Some contain errors that need to be fixed

# Specification 1: If all elements appear more than once, result is 1
# Status: INCORRECT - Uses dictionary mutation
# Problem: counts[elem] = ... modifies a dictionary, which is a side effect
# counts = {}
# for elem in arr:
#     counts[elem] = counts.get(elem, 0) + 1
# unique_elements = [elem for elem, count in counts.items() if count == 1]
# assert (len(unique_elements) == 0 and res == 1) or (len(unique_elements) > 0)


# Specification 2: Result is product of elements that appear exactly once
# Status: INCORRECT - Depends on unique_elements from Spec 1
# Problem: Uses reduce (acceptable) but depends on mutated state from Spec 1
# from functools import reduce
# from operator import mul
# expected_product = reduce(mul, unique_elements, 1) if unique_elements else 1
# assert res == expected_product


# Specification 3: If array is empty, result is 1
# Status: CORRECT
# assert (len(arr) > 0) or (res == 1)


# Specification 4: If array contains zero and zero appears once, result is 0
# Status: CORRECT
# assert (0 not in arr) or (arr.count(0) != 1) or (res == 0)


# Specification 5: Result is positive if all unique elements are positive or even number of negatives
# Status: INCORRECT - Depends on unique_elements from Spec 1
# Problem: unique_elements comes from mutated dictionary
# unique_negatives = sum(1 for elem in unique_elements if elem < 0)
# assert (len(unique_elements) == 0) or \
#        (unique_negatives % 2 == 0 and res > 0) or \
#        (unique_negatives % 2 == 1 and res < 0) or \
#        (0 in unique_elements and res == 0)


# ACCURACY RATE: 2/5 = 40%
# Correct: Specifications 3, 4
# Incorrect: Specifications 1, 2, 5 (all use dictionary mutation or depend on it)
